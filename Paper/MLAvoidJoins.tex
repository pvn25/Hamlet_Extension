\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage{amsmath}
\usepackage{graphicx,xspace,verbatim,comment}
\usepackage{hyperref,array,color,balance,multirow}
\usepackage{balance,float,url,amsfonts,alltt}
\usepackage{mathtools,rotating,amsmath,amssymb}
\usepackage{color,ifpdf,fancyvrb,array}
% \usepackage{algorithm,algpseudocode}
\usepackage{etoolbox,listings,subcaption}
\usepackage{bigstrut,morefloats}
%\usepackage[linesnumbered,boxruled]{algorithm2e}
\usepackage[boxruled]{algorithm2e}
\usepackage{pbox}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\newcommand{\eat}[1]{}

\newenvironment{packeditems}{
\begin{itemize}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{itemize}}

\newenvironment{packedenums}{
\begin{enumerate}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{enumerate}}

\setcopyright{acmcopyright}
% \setcopyright{rightsretained}

\acmDOI{10.475/123_4}
\acmISBN{123-4567-24-567/08/06}
\acmConference[WOODSTOCK'97]{ACM Woodstock conference}{July 1997}{El Paso, Texas USA} 
\acmYear{1997}
\copyrightyear{2016}
\acmPrice{15.00}

\begin{document}

\title{Stop That Join! Discarding Dimension Tables \\when Learning Infinite VC-Dimension Classifiers}

\author{Vraj Shah}
\affiliation{\institution{University of California, San Diego}}
\email{vps002@eng.ucsd.edu}
\author{Arun Kumar}
\affiliation{\institution{University of California, San Diego}}
\email{arunkk@eng.ucsd.edu}
\author{Xiaojin Zhu}
\affiliation{\institution{University of Wisconsin-Madison}}
\email{jerryzhu@cs.wisc.edu}

\begin{abstract}

\end{abstract}

% \keywords{ACM proceedings, \LaTeX, text tagging}

\maketitle

\section{Introduction}

Real-world relational databases typically contain multiple tables connected by \textit{database dependencies}~\cite{cowbook}. Thus, a common pre-processing step 
performed by data scientists when learning an ML model is to \textit{join} all tables they think might provide ``useful'' features for their prediction 
task~\cite{crossmine,orion,rendle,hamlet,olteanuf}.
But in general, an arbitrary join might duplicate records in the table with the target, thus violating the ``IID'' sampling assumption~\cite{hastie}. 
In response, ``non-IID'' statistical relational learning (SRL) models have been studied extensively~\cite{srlbook}. 
However, an important class of problems have fallen through the cracks in this dichotomy: 
joins that do \textit{not} duplicate records, viz., \textit{key-foreign key} (KFK) joins, and thus, do not technically violate the IID sampling assumption.

\paragraph*{Example (based on~\cite{orion})}
Consider an insurance data scientist using ML for a common classification task: predicting \textit{customer churn}. She starts with the main table (simplified 
for exposition): \texttt{Customers} (\underline{\texttt{CustomerID}}, \texttt{Churn}, \texttt{Gender}, \texttt{Age}, \texttt{Employer}). 
\texttt{Churn} is the target, while \texttt{Gender}, \texttt{Age}, and \texttt{Employer} are features. So far, this is a standard classification task.  
But then, she notices that table \texttt{Employers} (\underline{\texttt{Employer}}, \texttt{State}, \texttt{Revenue}) in her database with extra features about 
customers' employers (e.g., Google or Microsoft). \texttt{Customers}.\texttt{Employer} is then a \textit{foreign key} that connects these two tables. 
She joins the tables to bring in the extra features because she has a hunch that customers employed by rich corporations in coastal states might be less likely 
to churn. She then tries various classifiers, e.g., logistic regression or decision trees.

The join in our example is a KFK join that does not duplicate records: a customer has exactly one employer, although many customers might have the same employer.
SRL is perhaps an overkill for this setting. In a sense, the features brought in by a KFK join, which we call \textit{foreign features}, are just \textit{functions} of 
the foreign key feature; formally, this is called a \textit{functional dependency} (FD)~\cite{cowbook}.\footnote{Strictly speaking, an FD is different 
from a Key-Foreign Key Dependency (KFKD)~\cite{dbtheorybook}, but for most practical purposes in ML, KFKDs behave just like FDs~\cite{hamlet}.} 
An FD is analogous to arithmetic functions of numeric features (e.g., squares or products), except that foreign features typically provide a far more 
\textit{coarse-grained view} than the foreign key feature that functionally determines them.
Our example is not a one-off case; KFK joins are ubiquitous in various domains, including insurance, retail, telecommunications, Web security, 
and e-commerce. In fact, from conversations with data scientists in these domains, we learned that they routinely perform such KFK joins before applying regular 
IID ML classifiers (Section 3.1 gives more real-world examples). To introduce some terminology, the main table (\texttt{Customers} in our example)
is often called the \textit{fact table}, while the table with the foreign features (\texttt{Employers}) is called a \textit{dimension table}~\cite{cowbook}.

The coarse granularity of foreign features could indeed be helpful for \textit{interpretability} purposes. 
But from an \textit{accuracy} (generalization) perspective, an interesting question to answer is the following: 

\begin{center}\textit{Are foreign features really ``needed'' to improve ML accuracy?}\end{center}

At first glance, this question might seem surprising and counter-intuitive. Why discard foreign features a priori? Why will foreign features 
behave any differently than other features? 

The answer to the first question is clear: avoiding foreign features reduces the total number of features \textit{without running any computations}, 
which reduces the runtimes of ML and feature selection methods~\cite{guyon}; moreover, join computation times are also saved. 
Furthermore, worrying about fewer tables (and features) could help data scientists' productivity. For example, our conversations revealed that often, different tables 
are ``owned'' by different teams even within the same company, which causes logistical headaches for data scientists when procuring extra dimension tables.

The answer to the second question hinges on an obvious but key observation: \textit{given the foreign key, all foreign features are fixed} (the very definition of an FD!).
Formally, foreign features are \textit{redundant}, given the foreign key. 
So, a tempting conclusion is that foreign features (and KFK joins of this sort) are never needed for accuracy! Alas, recent work poured cold water
on this possibility: using a foreign key feature instead of foreign features often causes \textit{overfitting} even for simple \textit{linear} VC-dimension classifiers such as 
logistic regression and Naive Bayes~\cite{hamlet}. This is because foreign key features typically have much larger domains than foreign features (in our example, 
there are millions of employers but only $50$ states). Only when the number of training examples is far higher than the number of foreign key values ($>20$x) does the overfitting subside.

\textit{In this paper, we revisit the above question of whether foreign features are needed for accuracy for two popular \textit{infinite} VC-dimension classifiers: 
decision tree and SVM with RBF kernel.}

The natural expectation is that such complex models might face even higher overfitting than linear models if foreign features are discarded. 
Surprisingly, our extensive empirical and simulation analyses show that their behavior is the \textit{exact opposite}! We start by presenting empirical results on the 
real datasets with KFK joins from~\cite{hamlet}. For both classifiers, it turns out that in \textit{almost all cases}, dimension tables can be safely 
discarded. In contrast, for linear classifiers, they could be discarded in only half of the cases.

To understand the above surprising behavior in depth, we conduct an extensive simulation study using a decision tree. We generate data for a two-table KFK join 
and embed various ``true'' distributions for the target. This includes a known ``worst-case'' scenario for discarding foreign features a priori when learning a linear model, 
i.e., the (holdout) test errors blow up~\cite{hamlet}. We vary different properties of the data and the true distribution: 
numbers of features in each base table, numbers of training examples, foreign key domain size, noise in the data, and foreign key skew. 
In very few of these cases does discarding foreign features cause the error to rise significantly! Indeed, the only scenario where discarding foreign features seems to increase 
overfitting significantly is when the number of training examples is less than $3$x the number of foreign key values. This scenario arose in only one of the seven real datasets.
These results are in stark constrast to the results for linear models.

Our counter-intuitive empirical and simulation results raise open questions for ML theoretical research about why decision trees and RBF-SVMs are so robust to discarding 
foreign features even though they have infinite VC dimensions. As a step in this direction, we propose and analyze a key synthetic scenario that sheds some light into their behavior. 
We intuitively explain why decision trees are so robust when operating with the foreign key feature and often ignore foreign features. We also show that RBF-SVMs with foreign key 
features behave similar to a 1-nearest neighbor classifier due to the high dimensionality of foreign key features with one-hot encoding.
Still, more open questions remain; we hope our results contribute to more discussions and research on this topic.

\eat{
We extend the worst-case simulation scenario for linear models by replicating the foreign feature that determines the target multiple times. The idea is to make a model that uses 
the foreign key feature alone to overfit more than one that uses the foreign features. In particular, for the RBF-SVM, this scenario demonstrates that it behaves 
more similarly to a 1-nearest neighbor classifier when using the foreign key feature but less so when the number of relevant foreign features are increased.
}

Finally, from follow-up conversations with some data scientists, we learned that while they found foreign key features to be helpful for accuracy, they faced two new practical 
bottlenecks when using them for decision trees. The first is that the sheer size of a foreign key feature's domain makes it hard to interpret and visualize the trees. 
The second is that some foreign key values may not have any training examples even if they are known to be in the domain. 
We propose simple but effective heuristics to handle these bottlenecks and make foreign key features more practical. For the first bottleneck, we propose simpl lossy 
\textit{domain compression} methods that are configurable with a user-given size budget. For the second bottleneck, we propose a form of foreign key \textit{smoothing} 
that exploits foreign features as side information. We validate the accuracy of these techniques using both real and synthetic datasets.

\vspace{1mm}
\noindent Overall, the contributions of this paper are as follows:

\begin{packeditems}
\item To the best of our knowledge, this is the first paper to study the effects of discarding foreign features and KFK joins on infinite VC-dimension classifiers.
We present an empirical study with several real-world datasets that shows that decision trees and RBF-SVMs are surprisingly robust to discarding foreign features a priori.

\item We conduct a comprehensive and in-depth simulation study with a decision tree to assess the effects of different data properties on how safe foreign features are to discard.

\item We take a step towards formally analyzing the behavior of decision trees and RBF-SVMs in our setting and identify some open questions for ML theoretical research.

\item We identify two practical bottlenecks with foreign key features and resolve them with simple but effective heuristics.
\end{packeditems}


\paragraph*{Outline.} In the rest of this section, we discuss related prior work and position our work in context. Section 2 presents our notation, problem scope, and assumptions. 
Section 3 presents results on the real datasets, while Section 4 presents our in-depth simulation study and analysis. Section 5 presents our techniques to make foreign key features
more practical. We conclude in Section 6.

\subsection*{Related Work}

% We discuss the relationship of our work to key prior work from both the database, data mining, and ML literatures.

\paragraph*{Database Dependencies and ML}
The scenario of learning over joins of multiple tables without materializing the output of the join was studied in~\cite{orion,olteanuf,rendle,santoku},
but their goal was primarily to reduce runtimes of some ML techniques without affecting accuracy.
In contrast, our work focuses on the more fundamental question of whether foreign features are even needed for accuracy in the first place for complex ML models
such as decision trees and RBF-SVMs.
We first demonstrated the feasibility of discarding foreign features for linear VC dimension models such as logistic regression and Naive Bayes in~\cite{hamlet}.
In this work, we revisit that idea by demonstrating that popular infinite VC dimension models are counter-intuitively \textit{more} robust than linear models to avoiding 
foreign features, not \textit{less} as our VC dimension-based analysis in~\cite{hamlet} suggested. Further, we also evaluate mechanisms to make foreign key features more practical.
Embedded multi-valued dependencies (EMVDs) are database dependencies that are more general than functional dependencies~\cite{dbtheorybook}. 
The implication of EMVDs for probabilistic conditional independence in Bayesian networks was originally described by~\cite{pearl} and further explored by~\cite{wong}.
However, their use of EMVDs still requires computations over all features in the data instance. In contrast, our work demonstrates the dramatic effects of KFKDs and FDs 
in enabling us to avoid entire sets of features for complex ML models \textit{without performing any computations} on the foreign features.
There is a large body of work on statistical relational learning (SRL) to handle joins that cause duplicates in the fact table~\cite{srlbook}. But as mentioned before, 
our work focuses on the regular IID setting for which SRL might be an overkill.


\paragraph*{Feature Selection}

The data mining and ML communities have long studied the problem of feature selection to improve ML accuracy~\cite{guyonbook,hastie}.
In contrast, our goal is \textit{not} to design new feature selection methods. Rather, we want to demonstrate that foreign features quite often do not help improve 
accuracy when learning some popular complex ML classifiers. This can be viewed as a way of ``short-circuiting'' the feature selection process using database schema 
information, with the aim of obviating large amounts of computations over foreign features.
The trade-off between feature redundancy and relevancy is well-studied~\cite{guyonbook,leiyu,daphnekoller}. The conventional wisdom is that even a feature that is 
redundant might be highly relevant and hence, unavoidable in the mix~\cite{guyonbook}. Our work establishes, perhaps surprisingly, that this is \textit{not} the case 
for foreign features; even if a foreign feature is highly relevant, it can be safely discarded in most practical cases for decision trees and RBF-SVMs.
There is prior work on exploiting FDs in feature selection.
\cite{approxfds} infers approximate FDs using the dataset instance and exploits them during feature selection.
FOCUS~\cite{focus} is an approach to bias the input and reduce the number of features by performing some computations over those features.
Our work is orthogonal to all of these approaches that require computations over all features because we show that FDs caused by KFK joins imply that foreign features 
can often be discarded when learning complex ML models \textit{without even looking at the features} and obviously, without performing any computations on them!
To the best of our knowledge, no feature selection method exhibits such a dramatic capability that our work opens up.
Unsupervised dimensionality reduction methods such as random hashing or PCA are also popular~\cite{hastie,mitchellbook}. Our lossy compression techniques to 
reduce the domains of foreign key features for decision trees are inspired by such methods.



\section{Preliminaries}
We now explain our problem setting and notation, followed by an example. We then explain our assumptions and scope.

\subsection{Notation}
The setting we focus on is the following: the dataset has a set of table in the so-called \textit{star schema} with KFK dependencies.
Star schemas are ubiquitous in diverse applications ranging from insurance to recommendation systems~\cite{cowbook}.
The central table with the target is called the ``fact'' table, \textbf{S}. It has the schema $\textbf{S}(\underline{SID},Y, \textbf{X}_S, FK_1, \dots, FK_k)$,
while a ``dimension'' table is denoted $\textbf{R}_i$ ($i = 1$ to $k$) and it has the schema $\textbf{R}_i(\underline{RID_i},\textbf{X}_{R_i})$.
In the schema, $Y$ is the learning target (class label), $\textbf{X}_S$ and $\textbf{X}_{R_i}$ are vectors (sequences) of features, $RID_i$ is the primary key
of $\textbf{R}_i$, while $FK_i$ is a foreign key feature that refers to $\textbf{R}_i$. We call $\textbf{X}_S$ \textit{home} features and $\textbf{X}_{R_i}$ \textit{foreign} features.
For ease of exposition, we also treat \textbf{X} as a \textit{set} of features since the order among features is immaterial in our setting.
Let \textbf{T} denote the output of the projected equi-join (key-foreign key, or KFK for short) query that constructs the full training dataset by 
\textit{concatenating} the features from all base tables: $\textbf{T} \leftarrow \pi(\textbf{R} \bowtie_{RID=FK} \textbf{S})$. In general, its schema is 
$\textbf{T}(\underline{SID},Y,\textbf{X}_S,FK_1,\dots,FK_k,\textbf{X}_{R_1},\dots,\textbf{X}_{R_k})$.
In contrast to our setting, traditional ML formulations do not distinguish between home features, foreign keys, and foreign features.
\eat{\footnote{Note that this setting is 
different from the statistical relational learning (SRL) setting in which the joins could violate the IID assumption because they are not KFK (labeled examples in \textbf{S}
might get duplicated. KFK joins do not cause such repetitions.}}

\eat{
\paragraph*{Example}
Consider a common classification task for which ML classifiers are used, predicting \textit{customer churn}.
The fact table is \texttt{Customers} (\underline{\texttt{CustomerID}}, \texttt{Churn}, \texttt{Gender}, \texttt{Age}, \texttt{Employer}, \texttt{ZipCode}).
\texttt{Employer} and \texttt{Zipcode} are foreign key features that refer respectively to a customer's employer (e.g., Google or Microsoft) and the area 
where a customer lives. The respective dimension tables are \texttt{Employers} (\underline{\texttt{Employer}}, \texttt{State}, \texttt{Revenue}) 
and \texttt{Areas} (\underline{ZipCode}, \texttt{CrimeRate}, \texttt{AccidentRate}).
In such scenarios, data scientists typically join all base tables to bring in the extra features from the dimension tables. In this case, they might do so 
because of a hunch that customers employed by rich corporations in coastal states and living in ``safe'' areas are unlikely to churn.
}

\subsection{Assumptions and Scope}
For the sake of tractability, in this paper, we assume that all features are \textit{categorical} (nominal).\footnote{Numeric features can be discretized 
using standard techniques, e.g., binning~\cite{mitchellbook}.} We also focus on binary classification but our ideas can be easily applied to multi-class targets as well.
We assume that the foreign key features ($FK_i$) are not (primary) keys in the fact table, e.g., \texttt{Employer} does not uniquely identify a customer.\footnote{Primary 
keys in the fact table are \textit{not} generalizable features, unlike foreign keys.}
Finally, we also do not study the ``cold start'' issue because it is orthogonal to the focus of this paper~\cite{coldstart}. In other words, we assume that all features 
have known finite domains, possibly including a special ``Others'' placeholder to temporarily handle hitherto unseen values. In our example, this means that both 
\texttt{Employer} and \texttt{Gender} have known finite domains. In general, $FK_i$ can take values only from the given set of $\textbf{R}_i.RID_i$ values 
(new $FK_i$ values are mapped to ``Others''). Since ML models are rebuilt periodically in practice, new information can then be added to expand feature domains. 
We emphasize that our goal is \textit{not} to create new classification or feature selection algorithms, nor is to compare which algorithms yield lowest errors.
Our goal is to expose and analyze how KFKDs and FDs enable us to dramatically discard foreign features a priori when learning two popular infinite VC-dimension 
classifiers: decision tree (CART) and RBF-SVM.



\section{Empirical Study with Real Data}
\paragraph*{Datasets}
We take seven real normalized real-world datasets from ~\cite{hamlet}. The dataset statistics is provided in Table\ref{Table:datastats}.
\begin{table}
\centering
\includegraphics[width=\columnwidth,height=\textheight,keepaspectratio]{table1.pdf}
\caption{Dataset Statistics}
\label{Table:datastats}
\end{table}
We compare \textit{JoinAll} that joins all the base tables with \textit{NoJoin} which avoids all the dimension tables. Each approach is paired with Decision tree (CART) and SVM with RBF kernel based classifier. We compare the total runtime to learn the model and predict the outcome. We have used standard holdout validation method with the fact table split randomly into 50\%:25\%:25\% for training, validation and testing. Since the number of classes in the target for all the 7 datasets is 2, we use zero-one error. 
\begin{table*}
\centering
\includegraphics[width=2\columnwidth,height=\textheight,keepaspectratio]{table2.pdf}
\caption{End-to-end results real data}
\label{Table:svm_tree}
\end{table*}
\begin{table*}
\centering
\includegraphics[width=2\columnwidth,height=\textheight,keepaspectratio]{table3.pdf}
\caption{Performance accuracy for training data}
\label{Table:svm_train_tree}
\end{table*}
\begin{table}
\centering
\includegraphics[width=\columnwidth,height=\textheight,keepaspectratio]{table4.pdf}
\includegraphics[width=\columnwidth,height=\textheight,keepaspectratio]{table5.pdf}
\caption{Robustness study}
\label{Table:robustness}
\end{table}
\paragraph*{Decision Tree}
In order to evaluate classification performance of the decision tree, we perform a set of 20 cross validation runs using \textit{minsplit} and \textit{cp} as parameters to classify each of the data sets. \textit{minsplit} defines the number of observations that must exist in a node for a split to be attempted and any split that does not improve the fit by a factor of \textit{cp} is pruned off by validation procedure.   
\paragraph*{Gaussian SVM}
For Gaussian SVM we use the e1071 package which is the interface to the popular libsvm libraries. Gaussian SVMs requires tuning two parameters- C and gamma. The parameter C controls the cost of misclassification. A small C(soft margin) makes the cost of misclassification low thus allowing more of data points to lie on the wrong side of the margin. Large C (hard margin) implies high cost of misclassification that can potentially overfit the data. The gamma is a parameter of gaussian kernel given by: \[ k(x_i,x_j) = \exp(-\gamma \cdot \lVert{x_i - x_j} \rVert ^2 ) for \gamma > 0 \].
Where $x_{i}$ and $x_{j}$ are any two data points in the training dataset. A small $\gamma$ implies a gaussian with high variance and vice versa. The parameters C and gamma are determined by searching for maximum accuracy in the 2D-grid formed by different values of C and gamma on the validation set. C was sampled at $10^{-1}$, $10^{0}$, $10^{1}$, $10^{2}$, $10^{3}$ and gamma at $10^{-4}$, $10^{-3}$, $10^{-2}$, $10^{-1}$, $10^{0}$, $10^{1}$. Finally, the accuracies on hold out test data are reported in table\ref{Table:svm_tree}.

\section{In-depth Simulation Study}

We now present a simulation study to dive into the behavior of the decision tree classifier as we vary the 
properties of the underlying ``true'' data distribution. We focus on a simple two-table KFK join and sample datasets of 
different dimensions (numbers of tuples and numbers of features).
We use the decision tree classifier as the representative for this study because it exhibited the highest robustness to 
discarding dimension tables on the real datasets. Our simulation study will ``stress test'' its robustness.
But note that our simulation methodology is generic enough to be applicable to any other classifier because we only use 
standard generic notions of of error and variance.

\paragraph*{Setup and Data Synthesis}
There is one attribute table \textbf{R} ($k=1$), and all of $\textbf{X}_S$, $\textbf{X}_R$, and $Y$ are boolean (domain size $2$).
We control the ``true'' distribution $P(Y,\textbf{X})$ and sample labeled examples in an IID manner from it.
We study two different scenarios for what features \textbf{X} are used in $P$: \texttt{OneXr} and \texttt{XSXR}.
These scenarios represent opposite extremes for how likely the (test) error is likely to shoot up when $\textbf{X}_R$ is discarded
and $FK$ is used as a representative~\cite{hamlet}. In the \texttt{OneXr} scenario, a lone feature $X_r \in \textbf{X}_R$ is 
what is the only feature used in $P$; the rest of $\textbf{X}_R$ and $\textbf{X}_S$ are random noise (but note that $FK$ will not 
be noise because it functionally determines $X_r$). In the \texttt{XSXR} scenario, all features in $\textbf{X}_S$ and $\textbf{X}_R$
are used in $P$. Intuitively, \texttt{OneXr} is the worst-case scenario for discarding $\textbf{X}_R$ because $X_r$ is typically 
far more succinct than $FK$, which we expect to translate to less possibility of overfitting with NoJoin. Note that if we use $FK$ 
directly in $P$, $\textbf{X}_R$ can be more easily discarded because $FK$ conveys more information anyway; so, we skip this scenario.

The following data parameters are varied one at a time: number of training examples ($n_S$), size of foreign key domain ($|\mathcal{D}_{FK}|$ $=n_R$),
number of features in $\textbf{X}_R$ ($d_R$), and number of features in $\textbf{X}_S$ ($d_S$). We also sample $\frac{n_S}{4}$ examples each for the 
validation set (for hyper-parameter tuning) and the holdout test set (final indicator of error).
We generate $100$ different training datasets and measure the average test error and average net variance (as defined in~\cite{pedrobvd}) 
based on the different models obtained from these $100$ runs.


\begin{figure*}
\centering
\includegraphics[width=2\columnwidth,height=2\textheight,keepaspectratio]{onexr_row1.pdf}

\includegraphics[width=2\columnwidth,height=2\textheight,keepaspectratio]{onexr_row2.pdf}
\caption{OneXr simulation}
\label{Figure:OneXrSimulation}
\end{figure*}

\subsection{Scenario OneXr}
<<<<<<< HEAD

\begin{figure}
\centering
\includegraphics[width=\columnwidth,height=\textheight,keepaspectratio]{onexr_svm_1nn.pdf}
\caption{OneXr simulation for 1nn and SVM}
\label{Figure:OneXr1nnSVMSimulation}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=\columnwidth,height=\textheight,keepaspectratio]{onexr_jerrydt.pdf}
\includegraphics[width=\columnwidth,height=\textheight,keepaspectratio]{onexr_jerrysvm.pdf}
\includegraphics[width=\columnwidth,height=\textheight,keepaspectratio]{onexr_jerry1nn.pdf}
\caption{OneXr simulation for repeated Xr Features}
\label{Figure:OneXrjerry}
\end{figure}

=======
The ``true'' distribution is set as follows: $P(Y=0|X_r=0)=P(Y=1|X_r=1)=p$, where $p$ is called the probability skew parameter that controls the Bayes error (noise).
The exact procedure for sampling examples is as follows: (1) Construct tuples of \textbf{R} by sampling $\textbf{X}_R$ values randomly (each feature value 
is an independent coin toss). (2) Construct the tuples of \textbf{S} by sampling $\textbf{X}_S$ values randomly (independent coin tosses). (3) Assign $FK$ 
values to \textbf{S} tuples uniformly randomly from $\mathcal{D}_{FK}$. (4) Assign $Y$ values to \textbf{S} tuples by looking up into their respective $X_r$ 
value (implicit join on $FK = RID$) and sampling from the above true distribution.

We compare three settings based on what features are used by the model: 
\textit{UseAll}, which uses $\textbf{X} \equiv [\textbf{X}_S, FK, \textbf{X}_R]$, \textit{NoJoin}, which uses $\textbf{X} \equiv [\textbf{X}_S, FK]$ 
(i.e., discard $\textbf{X}_R$), and \textit{NoFK}, which uses $\textbf{X} \equiv [\textbf{X}_S, \textbf{X}_R]$ (i.e., discard $FK$).
Note that our hypothesis is that \textit{UseAll} and \textit{NoJoin} will exhibit similar errors in most cases, i.e., the foreign features 
($\textbf{X}_R$) might not really help improve accuracy. We include \textit{NoFK} to provide a reasonable lower bound on errors, since we know $FK$ 
is not directly a part of the true distribution.\footnote{In general, \textit{NoFK} could have much higher errors if $FK$ is part of the true distribution.}
Figure~\ref{Figure:OneXrSimulation} presents the results for the (holdout) test errors for varying each relevant data and distribution parameter, one at a time.

We see that regardless of the parameter being varied, in almost all cases, \textit{NoJoin} and \textit{JoinAll} have virtually identical errors (close to the Bayes 
error)! From inspecting the actual decision trees learned in these two settings, we found that in almost all cases, $FK$ was used heavily for partitioning and seldom was 
a feature from $\textbf{X}_R$, including $X_r$, used. This suggests that $FK$ can indeed act as a good representative of $\textbf{X}_R$ even in this extreme sccenario. 
In contrast to these results,~\cite{hamlet} reported that for linear models, the errors of \textit{NoJoin} shot up compared to \textit{JoinAll} (a gap of nearly $0.05$)
as the tuple ratio ($n_S : |\mathcal{D}_{FK}|$) starts falling below $20$. In stark contrast, as Figure~\ref{Figure:OneXrSimulation}(A2) shows, even for a tuple ratio of 
just $3$, \textit{NoJoin} and \textit{JoinAll} have similar errors with the decision tree. When $n_S$ becomes very low or when $|\mathcal{D}_{FK}$ becomes very high,
the absolute errors of \textit{JoinAll} and \textit{NoJoin} increase compared to \textit{NoFK}. This suggests that even though \textit{NoJoin} is comparable to 
\textit{JoinAll}, in regimes with very low tuple ratios, \textit{NoFK} is also worth trying. This is similar to the behavior seen on the Yelp dataset, since the tuple 
ratio for the user table was $< 3$. In almost all the other real datasets, we did not need to drop the foreign key features and \textit{NoJoin} sufficed.
Overall, we see that \textit{NoJoin} exhibits similar behavior as the state-of-the-art \textit{JoinAll} approach.
>>>>>>> origin/master

\begin{figure*}
\centering
\includegraphics[width=2\columnwidth,height=\textheight,keepaspectratio]{onexr_zipf.png}
\caption{OneXr Zipfian simulation}
\label{Figure:OneXrZipfSimulation}
\end{figure*}

<<<<<<< HEAD

\paragraph*{Scenario SkewedFK}
=======
\paragraph*{Scenario OneXrSkewedFK}
The regular OneXr scenario samples $FK$ values in \textbf{S} uniformly randomly from $\mathcal{D}_{FK}$ (step 3 in the procedure). We now ask if a \textit{skew} in 
the distribution of $FK$ values could widen the gap between \textit{JoinAll} and \textit{NoJoin}. To study this scenario, we modify the data generation procedure slightly:
in step 3, we sample $FK$ values with a Zipfian skew or a needle-and-thread skew. The Zipfian skew simply uses a Zipfian distribution for $P(FK)$ controlled by the Zipfian
skew parameter. The needle-and-thread skew allocates a large probability mass (parameter $p$) to a single $FK$ value (the ``needle'') and uniformly distributes the rest of 
the probability mass to all other $FK$ values (the ``thread''). For the linear model case,~\cite{hamlet} reported that as the skew parameters increased, the gap widened.
Figure~\ref{Figure:OneXrZipfSimulation} presents the results for the decision tree.

Surprisingly, the gap between \textit{NoJoin} and \textit{JoinAll} does not widen significantly regardless of the amount of skew introduced in either the Zipfian case or
the needle-and-thread case! This result further affirms the remarkable robustness of the decision tree in enabling us to discard foreign features. As expected, 
\textit{NoFK} is better in the regime of very few training examples, while overall, \textit{NoJoin} is quite similar to \textit{JoinAll}.
>>>>>>> origin/master


\begin{figure*}
\centering
\includegraphics[width=2\columnwidth,height=\textheight,keepaspectratio]{xsxr.png}
\caption{XsXr simulation}
\label{Figure:XsXrSimulation}
\end{figure*}

\subsection{Scenario XSXR}
Unlike the \textit{OneXr} scenario, we now create a true distribution that maps $\textbf{X} \equiv [\textbf{X}_S, \textbf{X}_R]$ to $Y$ without any Bayes error (noise).
The exact procedure for sampling examples is as follows: (1) Construct a true probability table (TPT) with entries for all possible values of 
$[\textbf{X}_S, \textbf{X}_R]$ and assign a random probability to each entry such that the total probability is $1$.
(2) For each entry in the TPT, pick a $Y$ value randomly and append the TPT entry; this ensures $H(Y|\textbf{X}) = 0$.
(3) Marginalize the TPT to obtain $P(\textbf{X}_R)$ and from it, sample $n_R = \mathcal{D}_{FK}$ tuples for \textbf{R} along with an associated sequential $RID$ value.
(4) In the original TPT, push the probability of each entry to $0$ if its $\textbf{X}_R$ values did not get picked for \textbf{R} in step 3.
(5) Renormalize the TPT so that the total probability is $1$ and sample $n_S$ examples ($Y$ values do not change) and construct \textbf{S}.
(6) For each tuple in \textbf{S}, pick its $FK$ value uniformly randomly from the subset of $RID$ values that map to its $\textbf{X}_R$ value in \textbf{R} (an implicit join).

We compare three settings: \textit{JoinAll}, \textit{NoJoin}, and \textit{NoFK}, with \textit{NoFK} meant to be a lower bound on the errors possible (because 
it uses the knowledge that $FK$ is not directly a part of the true distribution). Once again, our hypothesis is that \textit{JoinAll} and \textit{NoJoin} will exhibit similar 
errors in most cases, while \textit{NoFK} will perform better when the tuple ratio is low. Figure~\ref{Figure:XsXrSimulation} presents the results.

Once again, we see that \textit{NoJoin} and \textit{JoinAll} exhibit similar errors in almost all cases, with the largest gap being $0.017$ in Figure~\ref{Figure:XsXrSimulation}(C)).
Interestingly, even when the tuple ratio is close to $1$, the gap between \textit{NoJoin} and \textit{JoinAll} does not widen much. 
Figure~\ref{Figure:XsXrSimulation}(B)) shows that as $|\mathcal{D}_{FK}|$ increases, \textit{NoFK} remains at low overall errors, unlike both \textit{JoinAll} and \textit{NoJoin}.
But as we increase $d_R$ or $d_S$, the gap between \textit{JoinAll}/\textit{NoJoin} and \textit{NoFK} narrows because even \textit{NoFK} does not have enough training examples.
Of course, all gaps virtually disappear as the number of training examples increases, as shown by Figure~\ref{Figure:XsXrSimulation}(A).
Overall, we see that \textit{NoJoin} exhibits similar behavior as the state-of-the-art \textit{JoinAll} approach even in this scenario.


\subsection{Explanation and Open Questions}

\paragraph*{Decision Tree}

\paragraph*{Gaussian SVM}


\section{Making Foreign Key Features Practical}

\subsection{Foreign Key Domain Compression}

Clearly, foreign keys often act as good representatives of foreign features for \textit{accuracy}.
But they often pose a practical bottleneck for \textit{interpretability} due to the sheer size of their domains.
For example, it is nearly impossible to visualize a decision tree that uses a foreign key feature with 1000s of domain values.
Thus, to make foreign key features more practical, we consider a simple approach: \textit{compress} their domains to a (much) smaller 
user-defined domain size. This is inspired by the hashing trick~\cite{hashingtrick} but instead of an unsupervised random 
compression, we propose a deterministic supervised compression that optimizes some criterion related to accuracy. A key benefit of 
this approach is potentially higher accuracy, while obtaining an interpretable grouping of domain values.
We consider a natural criterion for maximization: \textit{mutual information} of the compressed foreign key with the target.

Formally, given the target $Y$ with domain $\mathcal{D}_Y$, a foreign key feature $FK$ with domain $\mathcal{D}_{FK}$ recoded as $[m]$ 
(where $m = |\mathcal{D}_{FK}|$) and a positive integer ``budget'' $l \ll m$, obtain a mapping $f: [m] \rightarrow [l]$ such that $I(Y; f(FK))$ is maximized,
or equivalently, $H(Y|f(FK))$ is minimized. Essentially, this is a partitioning problem in which we $\mathcal{D}_{FK}$ is partitioned into $l$ subsets. 
We reformulate this as a $0/1$-optimization problem over an $m \times l$ indicator variable matrix $v$.
The input constants are $|\mathcal{D}_Y| \cdot l$ frequency counts of the joint $(Y, FK)$ values in the training dataset, denoted $c_{y, x}$.
The problem then becomes the following:

\begin{equation*}
\begin{aligned}
& \underset{v}{\text{min}}
& & \sum_{y \in \mathcal{D}_Y} \sum_{j=1}^l \bigg(\sum_{i=i}^m c_{y,i} \cdot v_{i,j} \bigg) log \bigg(\frac{\sum_{y' \in \mathcal{D}_Y} \sum_{i=i}^m c_{y,i} \cdot v_{i,j}}{\sum_{i=i}^m c_{y,i} \cdot v_{i,j}}\bigg) \\
& \text{s.t.}
& & \sum_{j=1}^l v_{i,j} = 1, \; i = 1, \ldots, m
\end{aligned}
\end{equation*}

The optimization problem is non-convex and hard to optimize in a brute-force  way due to the number of variables (potentially millions). Thus, we propose two heuristics: \textit{SortBased} and \textit{TreeBased}.

\textit{SortBased} is a greedy approach in which we sort $\mathcal{D}_{FK}$ based on $H(Y|FK=z), ~z \in \mathcal{D}_{FK}$, compute the differences among adjacent pairs of values, and pick the boundaries corresponding to the top $l-1$ differences (ties broken randomly). This gives us an $l$-partition of $\mathcal{D}_{FK}$. The intuition is that by grouping $FK$ values that have comparable conditional entropy values, $H(Y|f(FK))$ is unlikely to increase much compared to $H(Y|FK)$. This approach operates on the training split.

\textit{TreeBased} is a post-hoc approach in which we first learn a decision tree that includes $FK$. Internally, the tree induces a partitioning of 
$\mathcal{D}_{FK}$. We simply construct $f$ using this partitioning information. Let $r$ be the number of subsets of $\mathcal{D}_{FK}$ at the lowest levels of the tree 
(finest-grained partitioning). If $r = l$, each subset directly corresponds to a value in $[l]$. If $r > l$, we use the same greedy approach used for the SortBased 
approach to merge the subsets until we end up with $l$ subsets. Finally, if $r < l$, we simply leave the partitioning as is because we already satisfy the user's budget;
the co-domain of $f$ is then only $[r]$ instead of $[l]$. This approach utilizes both the training and validation splits for learning the best decision tree that includes $FK$, with .

We now empirically compare the accuracy of the above two heuristics against random hashing as a baseline with $l$ as the number of buckets. 
We use the real-world datasets for this experiment and our methodology is as follows. We retain the 50:25:25 train-validate-test split.
\textit{SortBased} and random hashing use just the training split to construct $f$ and then compress $FK$ for the whole dataset. We then use
the validation set as before to tune the hyper-parameters and measure the holdout test error. For random hashing, we report the average across 
five runs. For \textit{TreeBased}, we first learn a decision tree using the original training and validation sets, construct $f$ and compress 
$FK$ for the whole dataset, and then measure the holdout test error.

\begin{figure}
\centering
\includegraphics[width=\columnwidth,height=\textheight,keepaspectratio]{smoothing.pdf}
\caption{Smoothing where (A) denotes random based and (B) represents the xr based smoothing}
\label{Figure:OneXr1nnSVMSimulation}
\end{figure}
\subsection{Foreign Key Smoothing}

A closely related issue caused by a large $|\mathcal{D}_{FK}|$ is that some $FK$ values might not be present in the training set but arise 
in the test set or during deployment. Note that this issue is different from the cold start issue because $\mathcal{D}_{FK}$ is still closed 
in this setting. This issue arises because there are simply not enough labeled examples to cover 
all of $\mathcal{D}_{FK}$ during training. Typically, this issue is handled using some form of \textit{smoothing}, e.g., Laplacian smoothing
for Naive Bayes by adding a pseudocount of $1$ to all frequency counts~\cite{mitchellbook}.
While similar smoothing techniques have been studied for probability estimation using decision trees~\cite{pedro2003}, to the best of our knowledge, 
this issue has not been handled in general for classification using decision trees. In fact, popular decision tree implementations in R simply 
crash if a value of $FK$ not seen during training arises during testing! Note that SVMs (or any other classifier operating on numeric 
feature spaces) do not face this issue due to the one-hot recoding of $FK$. 

We consider a simple approach to mitigate this issue: smooth by \textit{reassigning} an $FK$ value not seen during training to an $FK$ value 
seen during training. There are various ways to reassign; for simplicity sake, we only study two lightweight unsupervised methods. 
We use \textit{random} reassignment as a baseline but then study an alternative approach suited to our problem setting: use the foreign features 
($\textbf{X}_R$) to decide the reassignment. This is a natural choice because \textbf{R} provides auxiliary descriptive information about $FK$.
Our algorithm is simple: given a test example with $FK$ not seen during training, obtain an $FK$ seen during training whose corresponding 
$\textbf{X}_R$ feature vector has the minimum $l_0$ distance with the test example's $\textbf{X}_R$ (ties broken randomly). The $l_0$ distance is
simply the count of the number of pairwise mismatches of the respective features in the two $\textbf{X}_R$ feature vectors. 

The intuition for $\textbf{X}_R$-based smoothing is that if $\textbf{X}_R$ is part of the ``true'' distribution, it can provide better accuracy 
than random reassignment. But if $\textbf{X}_R$ is simply noise, it becomes similar to random reassignment.
To demonstrate our point, we now empirically compare their accuracy using our OneXr simulation scenario. Recall that a feature $X_r \in \textbf{X}_R$
determines the target (with some Bayes noise as before). We introduce a parameter $\gamma$ that is the ratio of the number of $FK$ values not seen 
during training to $|\mathcal{D}_{FK}|$. If $\gamma = 0$, no smoothing is needed; as $\gamma$ increases, more smoothing is needed.




\section{Conclusion and Future Work}



\bibliographystyle{ACM-Reference-Format}
\bibliography{MLAvoidJoins}

\end{document}
